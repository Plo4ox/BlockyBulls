import{aC as h,aD as w,aE as T,ab as y,aF as S,B as F,aG as b,z as $,v as j,aH as O,x,aI as N}from"./index-883b95b7.js";const v=h;function B(e){const{abi:s,args:t=[],name:n}=e,o=w(n,{strict:!1}),c=s.filter(r=>o?r.type==="function"?T(r)===n:r.type==="event"?v(r)===n:!1:"name"in r&&r.name===n);if(c.length===0)return;if(c.length===1)return c[0];let i;for(const r of c){if(!("inputs"in r))continue;if(!t||t.length===0){if(!r.inputs||r.inputs.length===0)return r;continue}if(!r.inputs||r.inputs.length===0||r.inputs.length!==t.length)continue;if(t.every((u,f)=>{const a="inputs"in r&&r.inputs[f];return a?d(u,a):!1})){if(i&&"inputs"in i&&i.inputs){const u=A(r.inputs,i.inputs,t);if(u)throw new S({abiItem:r,type:u[0]},{abiItem:i,type:u[1]})}i=r}}return i||c[0]}function d(e,s){const t=typeof e,n=s.type;switch(n){case"address":return y(e,{strict:!1});case"bool":return t==="boolean";case"function":return t==="string";case"string":return t==="string";default:return n==="tuple"&&"components"in s?Object.values(s.components).every((o,c)=>d(Object.values(e)[c],o)):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(n)?t==="number"||t==="bigint":/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(n)?t==="string"||e instanceof Uint8Array:/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(n)?Array.isArray(e)&&e.every(o=>d(o,{...s,type:n.replace(/(\[[0-9]{0,}\])$/,"")})):!1}}function A(e,s,t){for(const n in e){const o=e[n],c=s[n];if(o.type==="tuple"&&c.type==="tuple"&&"components"in o&&"components"in c)return A(o.components,c.components,t[n]);const i=[o.type,c.type];if((()=>i.includes("address")&&i.includes("bytes20")?!0:i.includes("address")&&i.includes("string")?y(t[n],{strict:!1}):i.includes("address")&&i.includes("bytes")?y(t[n],{strict:!1}):!1)())return i}}class H extends F{constructor(s){super(`Filter type "${s}" is not supported.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"FilterTypeNotSupportedError"})}}const g="/docs/contract/encodeEventTopics";function I(e){var l;const{abi:s,eventName:t,args:n}=e;let o=s[0];if(t){const u=B({abi:s,name:t});if(!u)throw new b(t,{docsPath:g});o=u}if(o.type!=="event")throw new b(void 0,{docsPath:g});const c=$(o),i=v(c);let r=[];if(n&&"inputs"in o){const u=(l=o.inputs)==null?void 0:l.filter(a=>"indexed"in a&&a.indexed),f=Array.isArray(n)?n:Object.values(n).length>0?(u==null?void 0:u.map(a=>n[a.name]))??[]:[];f.length>0&&(r=(u==null?void 0:u.map((a,p)=>Array.isArray(f[p])?f[p].map((k,E)=>m({param:a,value:f[p][E]})):f[p]?m({param:a,value:f[p]}):null))??[])}return[i,...r]}function m({param:e,value:s}){if(e.type==="string"||e.type==="bytes")return j(O(s));if(e.type==="tuple"||e.type.match(/^(.*)\[(\d+)?\]$/))throw new H(e.type);return x([e],[s])}function P(e){return!!(e&&typeof e=="object"&&"type"in e&&e.type==="event")}function _(e){const{signature:s}=e;let t;return P(s)?t=s:t=N(s),{abiEvent:t,hash:h(t),topics:I({abi:[t],args:e.filters})}}export{_ as p,v as t};
